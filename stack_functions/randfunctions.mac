simplify(list):=ev(list,simp);

stack_randseed(s) := block(RANDOM_STATE:make_random_state(s), errcatch(ev(set_random_state(RANDOM_STATE), simp)))$

/* The top level function */
rand(ex) := block(
  if setp(ex) then ex:listify(ex),
  ex:ev(ex, simp),
  if (integerp(ex)) then return(random(ex)),
  if (floatnump(ex)) then return(random(ex)),
  if (matrixp(ex)) then return(matrixmap(random, ex)),
  if (listp(ex)) then return(randlist(ex))
)$

/* Allow zero as an argument to random. */
rand_zero(ex):= block(
  if not(integerp(ex)) then error("rand_zero expects its argument to be an integer."),
  if is(ex<0) then error("rand_zero expects its argument to be non-negative."),
  if is(ex=0) then return(0),
  return(rand(ex))
)$

randlist(ex) := block(
  if (length(ex) > 0) then return(ex[ev(1+random(length(ex)),simp)]) else return([])
)$

/* Returns a random number from the set {lower, lower+step, lower+2*step, ... , final}. */
/* Jarno Ruokokoski, 29/10/2009                                                         */
rand_with_step(lower, upper, step_parameter) := block([temprand],
  temprand: rand(floor((upper-lower)/step_parameter)+1),
  return(ev(step_parameter*temprand+lower, simp))
)$

/* Returns a random integer from the set [lower,upper] such that it cannot be any value in list. This list can include values which are also random variables, for example, generated by rand_with_step. */
/* Jarno Ruokokoski, 29/10/2009 */
rand_with_prohib(lower, upper, list) := block([currents, retVal, kloop],
   currents: ev((makelist(i, i, lower, upper)), simp),
   for kloop:1 thru length(list) do block(
       currents: simplify(delete(list[ev(kloop, simp)], currents))
   ),
   retVal: rand(currents),
   return(retVal)
)$

/* CJS, 11/6/2021                                                  */
rand_selection_with_replacement(ex, n) := block(
  if setp(ex) then ex:listify(ex),
  if not(listp(ex)) then (
      error("rand_selection_with_replacement error: first argument must be a list."),
      return([])
      ),
  if not(integerp(n)) then (
      error("rand_selection_with_replacement error: second argument must be an integer."),
      return([])
      ),
  return(rand_selection_with_replacement_fun(ex, n))
)$

/* We can't use makelist here because of the simp:false requirement.
rand_selection_with_replacement_fun(ex, n) := makelist(rand(ex), k, 1, n)$
*/
rand_selection_with_replacement_fun(ex, n) := block(
   if is(n<=0) then return([]),
   append([rand(ex)], rand_selection_with_replacement_fun(ex, ev(n-1,simp)))
)$

/* Make a random selection of n different items from the list, or set ex. */
/* CJS, 7/6/2016                                                  */
rand_selection(ex, n) := block(
  if setp(ex) then ex:listify(ex),
  if not(listp(ex)) then (
      error("rand_selection error: first argument must be a list or set."),
      return([])
      ),
  if not(integerp(n)) then (
      error("rand_selection error: second argument must be an integer."),
      return([])
      ),
  if is(n>length(ex)) then (
      error("rand_selection error: insuffient elements in the list/set."),
      return([])
      ),
  return(rand_selection_fun(ex, n))
)$

rand_selection_fun(exin, n) := block([k],
  if is(n=0) then return([]),
  k: ev(rand(length(exin))+1, simp),
  cons(exin[k], rand_selection_fun(list_remove(exin, k), ev(n-1, simp)))
)$

/* Remove the n'th element from the list ex. */
list_remove(ex, n) := block([k, l],
    if is(n>length(ex)) or is (n<1) then return(ex),
    /* Using simplification make a list of indices, then without simplification use them. */
    l: ev(append(makelist(k, k, 1, n-1), makelist(k, k, n+1, length(ex))), simp),
    makelist(ex[k], k, l)
)$

/********************************************/
/***********  Random set generation *********/
/********************************************/
/* Could be implemented with rand_selection but would require two conversions
 * between sets and lists*/
random_subset(u):=
  disjoin(false, map(lambda([x], if rand(2)=0 then x), u)); 

random_subset_n(u,n) := 
  setify(rand_selection(listify(u),n));

/* random non-empty subset */
random_ne_subset(u) := random_subset_n(u, rand(cardinality(u))+1);


/* Create a number in a random range. */
rand_range([ex]) := block(
  if (length(ex)<2 or length(ex)>3) then error("rand_range must have 2 or 3 arguments."),
  if not(integerp(ex[1])) then error("rand_range expects its first argument to be an integer."),
  if not(integerp(ex[2])) then error("rand_range expects its second argument to be an integer."),
  if is(length(ex)=2) then return(ev(ex[1]+rand_zero(ex[2]-ex[1]), simp)),
  if not(integerp(ex[3])) then error("rand_range expects its third argument to be an integer."),
  return(ev(ex[1]+ex[3]*rand_zero(floor((ex[2]-ex[1])/ex[3])), simp))
)$

/* Helper function for constructing MCQ arrays. */
multiselqn(corbase, numcor, wrongbase, numwrong):=block([ta1, ta2, ta, version],
  if not(listp(corbase)) then error("multiselqn: first argument must be a list."),
  if not(listp(wrongbase)) then error("multiselqn: third argument must be a list."),
  if not(integerp(numcor)) then error("multiselqn: second argument must be an integer."),
  if not(integerp(numwrong)) then error("multiselqn: fourth argument must be an integer."),
  if length(corbase)<numcor then error("multiselqn: you have asked for more correct responses than are supplied in the list!"),
  if length(wrongbase)<numwrong then error("multiselqn: you have asked for more correct responses than are supplied in the list!"),
  ta1: maplist(lambda([ex], [ex, true]), rand_selection(corbase, numcor)),
  ta2: maplist(lambda([ex], [ex, false]), rand_selection(wrongbase, numwrong)),
  ta: random_permutation(append(ta1, ta2)),
  version: map(first, ta),
  return([ta, version])
)$

/* Helper function for constructing MCQ arrays with auto-generated alphabetic labels. Students choose the labels. */
multiselqnalpha([exs]):=block([corbase, numcor, wrongbase, numwrong, dispflag, ta1, ta2, ta3, talab, ta, version],
  if length(exs)<4 then error("multiselqnalpha must have at least four arguments."),
  corbase:first(exs),
  numcor:second(exs),
  wrongbase:third(exs),
  numwrong:fourth(exs),
  dispflag:"id",
  if length(exs)>4 then dispflag:fifth(exs),
  if not(listp(corbase)) then error("multiselqnalpha: first argument must be a list."),
  if not(listp(wrongbase)) then error("multiselqnalpha: third argument must be a list."),
  if not(integerp(numcor)) then error("multiselqnalpha: second argument must be an integer."),
  if not(integerp(numwrong)) then error("multiselqnalpha: fourth argument must be an integer."),
  if length(corbase)<numcor then error("multiselqnalpha: you have asked for more correct responses than are supplied in the list!"),
  if length(wrongbase)<numwrong then error("multiselqnalpha: you have asked for more correct responses than are supplied in the list!"),

  ta1: maplist(lambda([ex], [ex, true]), rand_selection(corbase, numcor)),
  ta2: maplist(lambda([ex], [ex, false]), rand_selection(wrongbase, numwrong)),
  ta3: random_permutation(append(ta1, ta2)),
  /* Add in a slightly different display here. */
  talab: ev(makelist(sconcat("(",ascii(96+i),")"), i, 1, length(ta3)), simp),
  ta:zip_with(lambda([ex1, ex2], [ex1, ex2[2], sconcat("<b>", ex1, "</b> ",
    if stringp(ex2[1]) then ex2[1] else stack_disp(ex2[1], dispflag))]), talab, ta3),
  version: map(first, ta3),
  return([ta, version])
)$

/* Helper function for constructing MCQ arrays where the values should not be shown to students. */
multiselqndisplay(corbase, numcor, wrongbase, numwrong):=block([ta1, ta2, ta, version],
  if not(listp(corbase)) then error("multiselqndisplay: first argument must be a list."),
  if not(listp(wrongbase)) then error("multiselqndisplay: third argument must be a list."),
  if not(integerp(numcor)) then error("multiselqndisplay: second argument must be an integer."),
  if not(integerp(numwrong)) then error("multiselqndisplay: fourth argument must be an integer."),
  if length(corbase)<numcor then error("multiselqndisplay: you have asked for more correct responses than are supplied in the list!"),
  if length(wrongbase)<numwrong then error("multiselqndisplay: you have asked for more correct responses than are supplied in the list!"),
  /*      */
  corbase: zip_with("[", ev(makelist(k,k,1,length(corbase)),simp), corbase),
  wrongbase: zip_with("[", ev(makelist(k,k,1+length(corbase),1+length(corbase)+length(wrongbase)),simp), wrongbase),
  ta1: maplist(lambda([ex], [first(ex), true, second(ex)]), rand_selection(corbase, numcor)),
  ta2: maplist(lambda([ex], [first(ex), false, second(ex)]), rand_selection(wrongbase, numwrong)),
  ta: random_permutation(append(ta1, ta2)),
  version: map(first, ta),
  /*      */
  return([ta, version])
)$
